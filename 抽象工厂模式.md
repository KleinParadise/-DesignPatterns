### 定义
提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。即需要一个工厂可以提供多个产品对象，而不是单一的产品对象。

### 模式结构
1. AbstractFactory：抽象工厂
2. ConcreteFactory：具体工厂
3. AbstractProduct：抽象产品
4. Product：具体产品

### 示例代码
```cpp
//抽象产品类
class AbstractProductA{
public:
    virtual void use()=0;
    //virtual ~AbstractProductA();
};

class ProductA1:public AbstractProductA{
public:
    void use(){
        printf("ProductA1 use enter");
    };
};

class ProductA2:public AbstractProductA{
public:
    void use(){
        printf("ProductA2 use enter");
    };
};

//抽象产品类
class AbstractProductB{
public:
    virtual void eat()=0;
    //virtual ~AbstractProductB();
};

class ProductB1:public AbstractProductB{
public:
    void eat(){
        printf("ProductB1 eat enter");
    };
};

class ProductB2:public AbstractProductB{
public:
    void eat(){
        printf("ProductB2 eat enter");
    };
};


//抽象工厂类
class AbstractFactory{
public:
    virtual AbstractProductA* createProductA() = 0;
    virtual AbstractProductB* createProductB() = 0;

};

class ConcreteFactory1 : public AbstractFactory{
public:
    AbstractProductA* createProductA(){
        return new ProductA1();
    };
    
    AbstractProductB* createProductB(){
        return new ProductB1();
    };
    
};

class ConcreteFactory2 : public AbstractFactory{
public:
    AbstractProductA* createProductA(){
        return new ProductA2();
    };
    
    AbstractProductB* createProductB(){
        return new ProductB2();
    };
    
};

int main(int argc, const char * argv[]) {
    // insert code here...
    AbstractFactory* pf1 = new ConcreteFactory1();
    AbstractProductA* pa =  pf1->createProductA();
    AbstractProductB* pb = pf1->createProductB();
    pa->use();
    pb->eat();
    
    AbstractFactory* pf2 = new ConcreteFactory2();
    AbstractProductA* pa2 =  pf2->createProductA();
    AbstractProductB* pb2 = pf2->createProductB();
    pa2->use();
    pb2->eat();
    
    return 0;
}
```
